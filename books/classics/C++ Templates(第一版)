第1章 關於本章 1
1.1 閱讀本書所需具備的知識 2
1.2 本書的整體結構 2
1.3 如何閱讀本書 2
1.4 關於程式設計風格的一些說明 3
1.5 標準和現實 5
1.6 代碼例子和更多資訊 5
1.7 回饋 5
第1部分 基礎 7
第2章 函數範本 9
2.1 初探函數範本 9
2.1.1 定義範本 9
2.1.2 使用範本 10
2.2 實參的演繹（deduction） 12
2.3 範本參數 13
2.4 重載函數範本 15
2.5 小結 19
第3章 類範本 21
3.1 類範本Stack的實現 21
3.1.1 類範本的聲明 22
3.1.2 成員函數的實現 23
3.2 類範本Stack的使用 25
3.3 類範本的特化 27
3.4 局部特化 29
3.5 缺省範本實參 30
3.6 小結 32
第4章 非類型範本參數 33
4.1 非類型的類範本參數 33
4.2 非類型的函數範本參數 36
4.3 非類型範本參數的限制 37
4.4 小結 38
第5章 技巧性基礎知識 39
5.1 關鍵字typename 39
5.2 使用this—> 41
5.3 成員範本 42
5.4 範本的範本參數 45
5.5 零初始化 51
5.6 使用字串作為函數範本的實參 52
5.7 小結 55
第6章 範本實戰 57
6.1 包含模型 57
6.1.1 連結器錯誤 57
6.1.2 標頭檔中的範本 59
6.2 顯式產生實體 60
6.2.1 顯式產生實體的例子 61
6.2.2 整合包含模型和顯式產生實體 62
6.3 分離模型 63
6.3.1 關鍵字export 63
6.3.2 分離模型的限制 65
6.3.3 為分離模型做好準備 66
6.4 範本和內聯 67
6.5 預編譯標頭檔 68
6.6 調試範本 70
6.6.1 理解長段的錯誤資訊 71
6.6.2 淺式產生實體 72
6.6.3 長符號串 75
6.6.4 跟蹤程式 75
6.6.5 oracles 79
6.6.6 archetypes 80
6.7 本章後記 80
6.8 小結 81
第7章 範本術語 83
7.1 “類範本”還是“範本類” 83
7.2 產生實體和特化 84
7.3 聲明和定義 85
7.4 一處定義原則 86
7.5 範本實參和範本參數 86
第2部分 深入範本 89
第8章 深入範本基礎 91
8.1 參數化聲明 91
8.1.1 虛成員函數 94
8.1.2 範本的連結 95
8.1.3 基本範本 96
8.2 範本參數 96
8.2.1 類型參數 97
8.2.2 非類型參數 97
8.2.3 範本的範本參數 98
8.2.4 缺省範本實參 99
8.3 範本實參 100
8.3.1 函數範本實參 101
8.3.2 類型實參 103
8.3.3 非類型實參 105
8.3.4 範本的範本實參 107
8.3.5 實參的等價性 109
8.4 友元 109
8.4.1 友元函數 110
8.4.2 友元範本 113
8.5 本章後記 113
第9章 範本中的名稱 115
9.1 名稱的分類 115
9.2 名稱查找 117
9.2.1 Argument—DependentLookup（ADL） 119
9.2.2 友元名稱插入 121
9.2.3 插入式類名稱 121
9.3 解析範本 123
9.3.1 非範本中的上下文相關性 123
9.3.2 依賴型類型名稱 125
9.3.3 依賴型範本名稱 127
9.3.4 using—declaration中的依賴型名稱 129
9.3.5 ADL和顯式範本實參 130
9.4 派生和類範本 131
9.4.1 非依賴型基類 131
9.4.2 依賴型基類 132
9.5 本章後記 134
第10章 產生實體 137
10.1 On—Demand產生實體 137
10.2 延遲產生實體 139
10.3 C++的產生實體模型 142
10.3.1 兩階段查找 142
10.3.2 POI 142
10.3.3 包含模型與分離模型 145
10.3.4 跨翻譯單元查找 146
10.3.5 例子 147
10.4 幾種實現方案 149
10.4.1 貪婪產生實體 151
10.4.2 詢問產生實體 152
10.4.3 反覆運算產生實體 153
10.5 顯式產生實體 155
10.6 本章後記 159
第11章 範本實參演譯 163
11.1 演繹的過程 163
11.2 演繹的上下文 165
11.3 特殊的演繹情況 167
11.4 可接受的實參轉型 168
11.5 類範本參數 169
11.6 缺省調用實參 169
11.7 Barton—Nackman方法 170
11.8 本章後記 172
第12章 特化與重載 175
12.1 當泛型代碼不再適用的時候 175
12.1.1 透明自訂 176
12.1.2 語義的透明性 177
12.2 重載函數範本 178
12.2.1 簽名 179
12.2.2 重載的函數範本的局部排序 182
12.2.3 正式的排序原則 183
12.2.4 範本和非範本 185
12.3 顯式特化 185
12.3.1 全域的類範本特化 186
12.3.2 全域的函數範本特化 189
12.3.3 全域成員特化 191
12.4 局部的類範本特化 194
12.5 本章後記 197
第13章 未來的方向 199
13.1 尖括弧Hack 199
13.2 放鬆typename的原則 200
13.3 缺省函數範本實參 201
13.4 字串文字和浮點型範本實參 202
13.5 放鬆範本的範本參數的匹配 204
13.6 typedef範本 206
13.7 函數範本的局部特化 207
13.8 typeof運算子 208
13.9 命名範本實參 210
13.10 靜態屬性 211
13.11 用戶端的產生實體診斷資訊 212
13.12 重載類範本 214
13.13 List參數 215
13.14 佈局控制 217
13.15 初始化器的演繹 218
13.16 函數運算式 219
13.17 本章後記 221
第3部分 範本與設計 223
第14章 範本的多態威力 225
14.1 動多態 225
14.2 靜多態 228
14.3 動多態和靜多態 231
14.3.1 術語 231
14.3.2 優點和缺點 232
14.3.3 組合這兩種多態 232
14.4 新形式的設計範本 233
14.5 泛型程式設計 234
14.6 本章後記 236
第15章 trait與policy類 239
15.1 一個實例：累加一個序列 239
15.1.1 fixedtraits 240
15.1.2 valuetrait 243
15.1.3 參數化trait 247
15.1.4 policy和policy類 249
15.1.5 trait和policy：區別在何處 251
15.1.6 成員範本和範本的範本參數 252
15.1.7 組合多個policie和／或trait 254
15.1.8 運用普通的反覆運算器進行累積 255
15.2 類型函數 256
15.2.1 確定元素的類型 257
15.2.2 確定class類型 259
15.2.3 引用和限定詞 261
15.2.4 promotiontrait 264
15.3 policytrait 267
15.3.1 唯讀的參數類型 268
15.3.2 拷貝、交換和移動 271
15.4 本章後記 275
第16章 範本與繼承 277
16.1 命名範本參數 277
16.2 空基類優化 281
16.2.1 佈局原則 281
16.2.2 成員作基類 284
16.3 奇特的遞迴範本模式 286
16.4 參數化虛擬性 289
16.5 本章後記 290
第17章 metaprogram 293
17.1 metaprogram的第一個實例 293
17.2 枚舉值和靜態常量 295
17.3 第2個例子：計算平方根 297
17.4 使用歸納變數 301
17.5 計算完整性 304
17.6 遞迴產生實體和遞迴範本實參 304
17.7 使用metaprogram來展開迴圈 306
17.8 本章後記 309
第18章 表示式範本 313
18.1 臨時變數和分割迴圈 314
18.2 在範本實參中編碼運算式 319
18.2.1 運算式範本的運算元 320
18.2.2 Array類型 323
18.2.3 運算子 325
18.2.4 回顧 327
18.2.5 運算式範本賦值 329
18.3 運算式範本的性能與約束 330
18.4 本章後記 331
第4部分 高級應用程式 335
第19章 類型區分 337
19.1 辨別基本類型 337
19.2 辨別組合類型 340
19.3 辨別函數類型 342
19.4 運用重載解析辨別枚舉類型 346
19.5 辨別class類型 348
19.6 辨別所有類型的函數範本 349
19.7 本章後記 352
第20章 智能指針 355
20.1 holder和trule 355
20.1.1 安全處理異常 356
20.1.2 holder 358
20.1.3 作為成員的holder 360
20.1.4 資源獲取於初始化 362
20.1.5 holder的局限 363
20.1.6 複製holder 364
20.1.7 跨函式呼叫來複製holder 365
20.1.8 trule 366
20.2 引用記數 368
20.2.1 計數器在什麼地方 370
20.2.2 併發訪問計數器 370
20.2.3 析構和釋放 371
20.2.4 CountingPtr範本 372
20.2.5 一個簡單的非侵入式計數器 375
20.2.6 一個簡單的侵入式計數器範本 377
20.2.7 常數性 378
20.2.8 隱式轉型 379
20.2.9 比較 381
20.3 本章後記 383
第21章 tuple 385
21.1 duo 385
21.2 可遞迴duo 390
21.2.1 域的個數 390
21.2.2 域的類型 392
21.2.3 域的值 393
21.3 tuple構造 398
21.4 本章後記 403
第22章 函數物件和回檔 405
22.1 直接調用、間接調用與內聯調用 406
22.2 函數指標與函數引用 409
22.3 成員函數指標 411
22.4 class類型的仿函數 414
22.4.1 class類型仿函數的第1個實例 414
22.4.2 class類型仿函數的類型 416
22.5 指定仿函數 417
22.5.1 作為範本類型實參的仿函數 417
22.5.2 作為函式呼叫實參的仿函數 418
22.5.3 結合函式呼叫參數和範本類型參數 419
22.5.4 作為非類型範本實參的仿函數 420
22.5.5 函數指標的封裝 421
22.6 內省 423
22.6.1 分析一個仿函數的類型 424
22.6.2 訪問參數的類型 425
22.6.3 封裝函數指標 426
22.7 函數物件組合 431
22.7.1 簡單的組合 432
22.7.2 混合類型的組合 436
22.7.3 減少參數的個數 440
22.8 值綁定 443
22.8.1 選擇綁定的目標 444
22.8.2 綁定簽名 446
22.8.3 實參選擇 447
22.8.4 輔助函數 453
22.9 仿函數操作：一個完整的實現 455
22.10 本章後記 457
附錄A 一處定義原則 459
A.1 翻譯單元 459
A.2 聲明和定義 460
A.3 一處定義原則的細節 461
A.3.1 程式的一處定義約束 461
A.3.2 翻譯單元的一處定義約束 463
A.3.3 跨翻譯單元的等價性約束 465
附錄B 重載解析 471
B.1 何時應用重載解析 472
B.2 簡化過的重載解析 472
B.2.1 成員函數的隱含實參 474
B.2.2 細化完美匹配 476
B.3 重載的細節 477
B.3.1 非範本優先 477
B.3.2 轉型序列 477
B.3.3 指針的轉型 478
B.3.4 仿函數和代理函數 480
B.3.5 其他的重載情況 481
參考資料 483
術語表 487
